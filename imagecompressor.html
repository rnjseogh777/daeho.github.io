<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>이미지 용량 압축 및 변환 (설치 불필요, 무제한 사용)</title>
  <meta name="description" content="여러 이미지를 브라우저에서 압축/변환하고 일괄 다운로드할 수 있습니다. 모든 처리는 로컬에서만 수행됩니다.">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <!-- 고정 헤더 (styles.css의 header/nav/brand/navlinks 사용) -->
  <header>
    <div class="container">
      <nav>
        <div class="brand">내 홈페이지<span class="logo-dot"></span></div>
        <div class="navlinks">
          <a href="index.html">Home</a>
          <a href="stock.html">Stock Market</a>
          <a href="matjip.html">맛집</a>
          <a href="index.html#contact" class="btn primary">문의하기</a>
        </div>
      </nav>
    </div>
  </header>

  <!-- 히어로 -->
  <main class="container">
    <section class="hero" data-anim>
      <p class="tag">브라우저만으로 간편하게</p>
      <h1>이미지 용량 압축 & 변환</h1>
      <p class="muted">설치 없이 무제한 사용. 드래그&드롭으로 업로드하고, 품질/크기를 조절해 한 번에 저장하세요. 모든 작업은 로컬에서만 처리됩니다.</p>
    </section>

    <!-- 설정/컨트롤 카드 -->
    <section>
      <div class="card" data-anim="2">
        <div class="section-title">
          <div class="bar"></div>
          <h2>설정</h2>
        </div>

        <div class="grid cols-3">
          <div>
            <label for="fmt" class="muted">출력 형식</label><br>
            <select id="fmt">
              <option value="webp" selected>WebP (권장)</option>
              <option value="jpeg">JPEG (알파 없음)</option>
              <option value="png">PNG (무손실, 효과 적을 수 있음)</option>
            </select>
          </div>

          <div>
            <label for="quality" class="muted">품질 <strong id="qv">80</strong></label><br>
            <input id="quality" type="range" min="10" max="100" value="80" />
          </div>

          <div>
            <label for="maxw" class="muted">가로 최대(px) <span class="muted">— 비우면 원본 유지</span></label><br>
            <input id="maxw" type="number" min="1" placeholder="예: 1200"/>
          </div>
        </div>

        <div style="margin-top:16px">
          <button id="btnPick" class="btn ghost" type="button">파일 선택</button>
          <button id="btnSaveAll" class="btn primary" type="button">일괄 다운로드</button>
          <button id="btnClear" class="btn ghost" type="button">목록 비우기</button>
        </div>
      </div>
    </section>

    <!-- 드롭 영역 카드 -->
    <section>
      <div class="card" id="drop" data-anim="3" aria-label="드래그 앤 드롭 영역">
        <div class="section-title">
          <div class="bar"></div>
          <h2>업로드</h2>
        </div>

        <p><strong>여기에 이미지 파일(다중) 드래그&드롭</strong></p>
        <p class="muted">또는 <button id="btnPickProxy" class="btn" type="button">파일 선택</button> 버튼을 눌러 선택하세요.</p>
        <input id="picker" type="file" accept="image/*" multiple hidden/>
        <p class="muted">모든 작업은 브라우저 내에서만 수행됩니다. 업로드되지 않습니다.</p>
      </div>
    </section>

    <!-- 목록 영역: 카드 그리드 -->
    <section>
      <div class="section-title">
        <div class="bar"></div>
        <h2>결과 파일</h2>
      </div>

      <div class="grid cols-3" id="list" aria-live="polite">
        <!-- JS가 .card.item 단위를 추가합니다 -->
      </div>

      <p class="muted" style="margin-top:12px">※ PNG→PNG는 용량 감소가 적을 수 있습니다. 대용량 PNG는 <strong>WebP</strong>로 내보내면 효과가 큽니다. 투명(알파)이 필요하면 WebP 유지, 필요 없으면 JPEG도 가능.</p>
      <p class="muted"><strong>주의:</strong> <u>JPEG → PNG 변환</u>은 용량이 <u>더 커질 수</u> 있습니다. 형식 변환 전에 목적을 확인하세요.</p>
    </section>
  </main>

  <!-- 푸터 (styles.css의 .footer 클래스를 사용) -->
  <div class="footer">
    <div class="container">
      <small>© 2025 rfp.kr</small>
    </div>
  </div>

  <script>
    // ====== 엘리먼트 ======
    const $drop = document.getElementById('drop');
    const $picker = document.getElementById('picker');
    const $btnPick = document.getElementById('btnPick');       // 상단 설정 카드의 파일 선택
    const $btnPickProxy = document.getElementById('btnPickProxy'); // 드롭 카드 내부의 파일 선택
    const $list = document.getElementById('list');
    const $fmt = document.getElementById('fmt');
    const $quality = document.getElementById('quality');
    const $qv = document.getElementById('qv');
    const $maxw = document.getElementById('maxw');
    const $btnClear = document.getElementById('btnClear');
    const $btnSaveAll = document.getElementById('btnSaveAll');

    // 초기 품질 반영
    $qv.textContent = $quality.value;
    $quality.addEventListener('input', () => { $qv.textContent = $quality.value; });

    // 파일 선택 버튼들
    if ($btnPick) $btnPick.onclick = () => $picker.click();
    if ($btnPickProxy) $btnPickProxy.onclick = () => $picker.click();
    $picker.onchange = (e) => handleFiles(e.target.files);

    // 드래그 앤 드롭
    ['dragenter','dragover'].forEach(ev=>{
      $drop.addEventListener(ev, e=>{
        e.preventDefault(); e.stopPropagation();
        // hover 느낌만: 카드 호버 효과는 styles.css가 처리
        $drop.setAttribute('data-anim', '3');
      });
    });
    ['dragleave','drop'].forEach(ev=>{
      $drop.addEventListener(ev, e=>{
        e.preventDefault(); e.stopPropagation();
        $drop.setAttribute('data-anim', '3');
      });
    });
    $drop.addEventListener('drop', e => handleFiles(e.dataTransfer.files));

    // Blob URL 레지스트리
    const createdUrls = new Set();

    // 목록 비우기
    $btnClear.onclick = ()=>{
      createdUrls.forEach(u => URL.revokeObjectURL(u));
      createdUrls.clear();
      $list.innerHTML='';
    };

    function fmtBytes(bytes){
      if(bytes===0) return '0 B';
      const k=1024, dm=1, sizes=['B','KB','MB','GB'];
      const i=Math.floor(Math.log(bytes)/Math.log(k));
      return parseFloat((bytes/Math.pow(k,i)).toFixed(dm))+' '+sizes[i];
    }

    async function handleFiles(fileList){
      const files = Array.from(fileList).filter(f => /^image\\//.test(f.type));
      for (const f of files){
        await processFile(f);
      }
    }

    async function processFile(file){
      const origUrl = URL.createObjectURL(file);
      createdUrls.add(origUrl);
      try{
        const img = await loadImage(origUrl);
        const {blob, outName, outW, outH} = await encode(img, file.name);
        const outUrl = URL.createObjectURL(blob);
        createdUrls.add(outUrl);

        // ====== 카드 아이템 구성 (styles.css의 .card, .btn, .muted만 사용) ======
        const card = document.createElement('div');
        card.className = 'card item';
        card.dataset.outUrl = outUrl;
        card.dataset.origUrl = origUrl;

        // 파일명 + 해상도
        const titleWrap = document.createElement('div');
        titleWrap.className = 'section-title';
        const bar = document.createElement('div');
        bar.className = 'bar';
        const h3 = document.createElement('h3');
        h3.textContent = outName;
        titleWrap.appendChild(bar);
        titleWrap.appendChild(h3);

        // 상세 정보
        const meta = document.createElement('p');
        meta.className = 'muted';
        meta.innerHTML = \`원본 <strong>\${escapeHtml(file.name)}</strong> → 출력 <strong>\${escapeHtml(outName)}</strong> (\${outW}×\${outH})\`;

        // 크기 변화
        const sizes = document.createElement('p');
        sizes.className = 'muted';
        sizes.textContent = \`\${fmtBytes(file.size)} → \${fmtBytes(blob.size)}\`;

        // 액션 버튼
        const actions = document.createElement('div');
        const a = document.createElement('a');
        a.href = outUrl;
        a.download = outName;
        a.className = 'btn';
        a.textContent = '다운로드';

        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'btn ghost';
        del.textContent = '삭제';
        del.onclick = () => removeCard(card);

        actions.appendChild(a);
        actions.appendChild(del);

        card.appendChild(titleWrap);
        card.appendChild(meta);
        card.appendChild(sizes);
        card.appendChild(actions);

        $list.appendChild(card);
      }catch(err){
        console.error(err);
        URL.revokeObjectURL(origUrl);
        createdUrls.delete(origUrl);
      }
    }

    function loadImage(url){
      if('createImageBitmap' in window){
        return fetch(url).then(r=>r.blob()).then(b=>createImageBitmap(b));
      }
      return new Promise((res,rej)=>{
        const img = new Image();
        img.onload = ()=> res(img);
        img.onerror = rej;
        img.src = url;
      });
    }

    async function encode(bitmapOrImg, inName){
      const maxw = parseInt($maxw.value,10);
      const origW = bitmapOrImg.width || bitmapOrImg.naturalWidth;
      const origH = bitmapOrImg.height || bitmapOrImg.naturalHeight;
      let outW = origW, outH = origH;
      if(maxw && maxw > 0 && origW > maxw){
        outW = maxw;
        outH = Math.round(origH * (maxw / origW));
      }

      const cnv = document.createElement('canvas');
      cnv.width = outW; cnv.height = outH;
      const ctx = cnv.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(bitmapOrImg, 0, 0, outW, outH);

      const fmt = $fmt.value; // webp/jpeg/png
      let type = 'image/webp';
      if(fmt==='jpeg') type = 'image/jpeg';
      if(fmt==='png') type = 'image/png';

      const q = Math.max(0.1, Math.min(1, ($quality.value|0)/100));
      const blob = await new Promise(res => cnv.toBlob(res, type, fmt==='png'?undefined:q));

      const base = inName.replace(/\\.[^.]+$/, '');
      const ext = fmt==='jpeg'? 'jpg' : fmt;
      const outName = \`\${base}-min.\${ext}\`;
      return {blob, outName, outW, outH};
    }

    function removeCard(card){
      const outUrl = card?.dataset?.outUrl;
      const origUrl = card?.dataset?.origUrl;
      if(outUrl){ URL.revokeObjectURL(outUrl); createdUrls.delete(outUrl); }
      if(origUrl){ URL.revokeObjectURL(origUrl); createdUrls.delete(origUrl); }
      card.remove();
    }

    // ===== 일괄 다운로드 =====
    $btnSaveAll.onclick = async ()=>{
      const cards = Array.from($list.querySelectorAll('.card.item'));
      if(cards.length===0) return;
      for(let i=0;i<cards.length;i++){
        const a = cards[i].querySelector('a.btn');
        if(a){ a.click(); }
        await wait(180);
      }
    };
    function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

    function escapeHtml(s){
      return (s||'').toString().replace(/[&<>\"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]));
    }
  </script>
</body>
</html>
